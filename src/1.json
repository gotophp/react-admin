{
  "id": 32,
  "user_id": 1,
  "state": 1,
  "title": "微信扫小程序码实现网页端登录",
  "preview": "http://qiniu.einsition.com/article/a32/wxmeyafx0afxw5dw.png",
  "heat": 149685,
  "cache": {
    "views_count": 3909,
    "favorites_count": 19,
    "likes_count": 30,
    "comments_count": 76
  },
  "created_at": "2019-08-09 14:14:42",
  "updated_at": "2021-09-26 21:21:13",
  "deleted_at": null,
  "created_at_timeago": "2019-08-09 14:14",
  "updated_at_timeago": "1秒前",
  "friendly_views_count": "3.9k",
  "friendly_comments_count": "76",
  "friendly_likes_count": "30",
  "highlights": [],
  "has_favorited": false,
  "has_liked": false,
  "combine_markdown": "常见的微信扫码登录有两种\n\n1、[微信开放平台](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419316505&token=&lang=zh_CN)\n\n2、[微信服务号](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)\n\n这两种方式都需要提交企业资料认证和300元年费，有些想要学习或者自己的网站没有盈利的，其实不舍得花这个钱，特别是个人开发者，没有企业资料去做认证。\n\n既然没法做企业认证，那我们就把矛头指向微信小程序了。\n\n微信小程序无论是个人还是企业的，都开放了获取用户的基本信息，无须认证，不收费。而且，还提供了 1 个可以生成带参数的，数量暂无限制[小程序码](https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html)接口，所以我们就可以通过这个接口实现扫码登录了。\n\n\n### 实现原理\n* 登录页面从服务端获取一个带uuid参数的小程序码，然后创建一个websocket并带上这个uuid参数（用于网页端和小程序的通信绑定）\n* 用户通过微信扫码授权后把登录code、用户信息和uuid参数提交到服务端\n* 服务端根据登录code获取openId，然后在根据openId创建用户，最后生成user token广播给前端（通过uuid找到对应的soket链接并发送）\n* 前端接收到token后，auth 登录，页面再重载一下，流程完毕\n\n### 实战\n\n#### 获取小程序码\n\n前端获取小程序码并创建websocket\n\n```typescript\nimport { Form, Tabs, Input, Button, Checkbox, Spin, Icon, message } from 'antd';\nimport React, { Component } from 'react';\nimport { FormComponentProps } from 'antd/es/form';\nimport { connect } from 'dva';\nimport { Link } from 'umi';\nimport { ConnectState, ConnectProps } from '@/models/connect';\nimport { getLoginCode } from './service';\nimport styles from './style.less';\n\nconst FormItem = Form.Item;\nconst { TabPane } = Tabs;\n\ninterface LoginProps extends ConnectProps, FormComponentProps {\n  submitting: boolean;\n}\n\ninterface LoginState {\n  base64Img: string;\n  codeExpired: boolean;\n  codeLoading: boolean;\n}\n\n@connect(({ loading }: ConnectState) => ({\n  submitting: loading.effects['authLogin/login'],\n}))\nclass Login extends Component<LoginProps, LoginState> {\n  static socketTimeout = 120000;\n\n  state: LoginState = {\n    base64Img: '',\n    codeExpired: false,\n    codeLoading: false,\n  };\n\n  ws: any;\n\n  timer: any;\n\n  componentDidMount() {\n    this.createWebSocket();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.timer);\n    if (this.ws && this.ws.readyState === 1) {\n      this.ws.close();\n    }\n  }\n\n  createWebSocket = async () => {\n    clearTimeout(this.timer);\n\n    if (this.ws && this.ws.readyState === 1) {\n      this.ws.close();\n    }\n\n    this.setState({ codeExpired: false, codeLoading: true });\n\n    const { data: { base64_img: base64Img, token } } = await getLoginCode();\n\n    const socketUrl = `wss://${window.location.host}/wss?token=${token}`;\n    this.ws = new WebSocket(socketUrl);\n\n    this.ws.addEventListener('message', (e: any) => {\n      const { data: msg } = e;\n\n      const { event, data } = JSON.parse(msg);\n      /* eslint no-case-declarations:0 */\n      switch (event) {\n        case 'App\\\\Events\\\\WechatScanLogin':\n          const { token, permissions } = data;\n\t\t  // 获取到token后Auth登录\n          this.props.dispatch({\n            type: 'authLogin/loginSuccess',\n            payload: { token, permissions },\n            callback: () => {\n              message.success('登录成功！');\n              clearTimeout(this.timer);\n              if (this.ws && this.ws.readyState === 1) {\n                this.ws.close();\n              }\n            },\n          });\n          break;\n        default:\n          break;\n      }\n    });\n\n    this.setState({ base64Img, codeExpired: false, codeLoading: false });\n\n    this.timer = setTimeout(this.handleWebSocketTimeout, Login.socketTimeout);\n  };\n\n  handleWebSocketTimeout = () => {\n    if (this.ws && this.ws.readyState === 1) {\n      this.ws.close();\n    }\n\n    this.setState({ codeExpired: true });\n  };\n\n  handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    const { form } = this.props;\n\n    form.validateFields({ force: true }, (err: any, values: object) => {\n      if (!err) {\n        const { dispatch } = this.props;\n        dispatch({\n          type: 'authLogin/login',\n          payload: values,\n        });\n      }\n    });\n  };\n\n  renderCode = () => {\n    const { base64Img, codeExpired, codeLoading } = this.state;\n    if (codeExpired) {\n      return (\n        <>\n          <Icon type=\"close-circle\" /><span className={styles.noticeTitle}>小程序码已失效</span>\n          <Button\n            className={styles.noticeBtn}\n            type=\"primary\"\n            size=\"large\"\n            block\n            onClick={this.createWebSocket}\n          >\n            刷新小程序码\n          </Button>\n        </>\n      );\n    }\n\n    return (\n      <>\n        <p>微信扫码后点击“登录”，</p>\n        <p>即可完成账号绑定及登录。</p>\n        {\n          codeLoading\n            ? <Spin indicator={<Icon type=\"loading\" spin />} tip=\"正在加载...\" />\n            : <img src={`data:image/png;base64,${base64Img}`} alt=\"小程序码\" width=\"260\" height=\"260\" />\n        }\n      </>\n    );\n  };\n\n  render() {\n    const { form, submitting } = this.props;\n    const { getFieldDecorator } = form;\n\n    return (\n      <div className={styles.main}>\n        <Form onSubmit={this.handleSubmit}>\n          <Tabs size=\"large\">\n            <TabPane tab=\"微信扫码登录\" key=\"1\">\n              <div className={styles.qrcodeBox}>\n                {this.renderCode()}\n              </div>\n            </TabPane>\n            <TabPane tab=\"账户密码登录\" key=\"2\">\n              <div>\n                <FormItem hasFeedback>\n                  {getFieldDecorator('account', {\n                    rules: [{ required: true, message: '请输入账户名称！' }],\n                  })(<Input size=\"large\" placeholder=\"账户名称\" />)}\n                </FormItem>\n                <FormItem hasFeedback>\n                  {getFieldDecorator('password', {\n                    rules: [{ required: true, message: '请输入账户密码！'}],\n                  })(<Input.Password size=\"large\" placeholder=\"账户密码\" />)}\n                </FormItem>\n                <FormItem>\n                  {getFieldDecorator('remember')(\n                    <Checkbox>自动登录</Checkbox>,\n                  )}\n                  <Link style={{ float: 'right' }} to=\"#\">\n                    忘记密码\n                  </Link>\n                  <Button size=\"large\" type=\"primary\" block loading={submitting} htmlType=\"submit\">\n                    登录\n                  </Button>\n                </FormItem>\n              </div>\n            </TabPane>\n          </Tabs>\n        </Form>\n      </div>\n    );\n  }\n}\n\nexport default Form.create<LoginProps>()(Login);\n```\n\n服务端生成小程序码逻辑\n\n```php\n<?php\n\nnamespace App\\Http\\Controllers\\V2;\n\nuse EasyWeChat;\nuse Illuminate\\Support\\Str;\nuse EasyWeChat\\Kernel\\Http\\StreamResponse;\nuse JWTFactory;\nuse JWTAuth;\n\nclass WechatController extends Controller\n{\n    public function loginCode()\n    {\n        $uuid = Str::random(16);\n\n        $miniProgram = EasyWeChat::miniProgram();\n\n        $response = $miniProgram->app_code->getUnlimit('scan-login/' . $uuid, [\n            'page' => 'pages/auth/scan-login',\n            'width' => 280,\n        ]);\n\n        if ($response instanceof StreamResponse) {\n            $payload = JWTFactory::setTTL(2)->sub($uuid)->make();\n            $token = (string)JWTAuth::encode($payload);\n\n            $response->getBody()->rewind();\n\n            $base64_img = base64_encode($response->getBody()->getContents());\n\n            $data = compact('token', 'base64_img');\n            return compact('data');\n        }\n\n        return $response;\n    }\n}\n```\n\n### 小程序扫码处理逻辑\n```js\n// pages/auth/scan-login.js\nimport regeneratorRuntime from '../../utils/runtime'\nconst { setToken } = require('../../utils/authority');\nconst { login } = require('../../utils/helpers')\n\nPage({\n  data: {\n    uuid: '',\n  },\n\n  async onGetUserInfo(e) {\n    if (e.detail.userInfo) { // 用户按了允许授权按钮\n      setToken();\n      await login({ uuid: this.data.uuid });\n\n      wx.reLaunch({\n        url: '/pages/user/index'\n      })\n\n      wx.showToast({\n        title: '登录成功',\n        icon: 'none',\n      });\n    }\n  },\n\n  async onLoad(query) {\n    const scene = decodeURIComponent(query.scene);\n    const uuid = scene.split('/')[1];\n    this.setData({ uuid });\n  },\n})\n```\n\n```xml\n<!-- pages/auth/scan-login.wxml -->\n<view class=\"page\">\n    <view class=\"page__hd\">\n      <view style='text-align: center'>\n        <image src=\"/images/icon/pc.png\" style=\"width: 200px; height: 200px\" />\n        <view style='text-align: center'>\n          <text style='font-size: 32rpx'>WEB 端登录确认</text>\n        </view>\n      </view>\n\n      <view style='text-align: center'>\n        <button\n          style='width: 400rpx'\n          class=\"weui-btn\"\n          type=\"primary\"\n          open-type=\"getUserInfo\"\n          bindgetuserinfo=\"onGetUserInfo\"\n        >\n          登录\n        </button>\n        <view style='font-size: 32rpx; margin-top: 40rpx; color: rgba(0, 0, 0, 0.5)'>\n          <navigator open-type=\"exit\" target=\"miniProgram\">取消登录</navigator>\n        </view>\n      </view>\n    </view>\n</view>\n```\n\n#### 扫码授权后服务端处理逻辑\n\n```php\npublic function login(Request $request)\n{\n\t$this->validate($request, [\n\t\t'code' => 'required',\n\t]);\n\n\t$code = $request->input('code');\n\t$miniProgram = EasyWeChat::miniProgram();\n\t$miniProgramSession = $miniProgram->auth->session($code);\n\n\t$openId = $miniProgramSession->openid;\n\t$sessionKey = $miniProgramSession->session_key;\n\t\n\t$lockName = self::class . \"@store:$openId\";\n\t$lock = Cache::lock($lockName, 60);\n\tabort_if(!$lock->get(), 422, '操作过于频繁，请稍后再试！');\n\n\t$userInfo = $request->input('userInfo');\n\t$rawData = $request->input('rawData');\n\t$signature = $request->input('signature');\n\t$signature2 = sha1($rawData . $sessionKey);\n\n\tabort_if($signature !== $signature2, 403, '数据不合法！');\n\n\t$user = User::where('we_chat_openid', $openId)->first();\n\n\tif (!$user) {\n\t\t$user = new User;\n\t\t// $user->name = Arr::get($userInfo, 'nickName', '');\n\t\t$user->we_chat_openid = $openId;\n\t\t$user->user_info = $userInfo;\n\n\t\t$user->save();\n\t}\n\n\t$token = Auth::login($user);\n\n\t$data = [\n\t\t'access_token' => $token,\n\t\t'token_type' => 'Bearer',\n\t\t'expires_in' => Carbon::now()->addMinutes(config('jwt.ttl'))->toDateTimeString(),\n\t\t'unread_count' => $user->unreadNotifications()->count(),\n\t];\n\n\t$lock->release();\n\n\t$uuid = $request->input('uuid');\n\n\tif ($uuid) {\n\t\t$permissions = $user->getAllPermissions()->pluck('name');\n\t\t// 把token广播给前端\n\t\tevent(new WechatScanLogin($uuid, \"Bearer $token\", $permissions));\n\t}\n\n\treturn compact('data');\n}\n```\n\nWechatScanLogin 事件\n\n```php\n<?php\n\nnamespace App\\Events;\n\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n\nclass WechatScanLogin implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n\n    protected $uuid;\n\n    public $token;\n\n    public $permissions;\n\n    public function __construct($uuid, $token, $permissions)\n    {\n        $this->uuid = $uuid;\n        $this->token = $token;\n        $this->permissions = $permissions;\n    }\n\n    public function broadcastOn()\n    {\n        return new PrivateChannel('scan-login.' . $this->uuid);\n    }\n}\n```\n\n### websocket server\n```js\nconst WebSocket = require('ws'); // socket.io 支持的协议版本（4）和 微信小程序 websocket 协议版本（13）不一致，所以选用ws\nconst Redis = require('ioredis');\nconst fs = require('fs');\nconst ini = require('ini');\nconst jwt = require('jsonwebtoken');\nconst url = require('url');\n\nconst config = ini.parse(fs.readFileSync('./.env', 'utf8')); // 读取.env配置\n\nconst redis = new Redis({\n    port: env('REDIS_PORT', 6379),          // Redis port\n    host: env('REDIS_HOST', '127.0.0.1'),   // Redis host\n    // family: 4,           // 4 (IPv4) or 6 (IPv6)\n    password: env('REDIS_PASSWORD', null),\n    db: 0,\n});\n\nconst wss = new WebSocket.Server({\n    port: 6001,\n    clientTracking: false,\n    verifyClient({req}, cb) {\n        try {\n            const urlParams = url.parse(req.url, true);\n            const token = urlParams.query.token || req.headers.authorization.split(' ')[1];\n            const jwtSecret = env('JWT_SECRET');\n            const algorithm = env('JWT_ALGO', 'HS256');\n\n            const {sub, nbf, exp} = jwt.verify(token, jwtSecret, {algorithm});\n\n            if (Date.now() / 1000 > exp) {\n                cb(false, 401, 'token已过期.')\n            }\n\n            if (Date.now() / 1000 < nbf) {\n                cb(false, 401, 'token未到生效时间.')\n            }\n\n            if (!sub) {\n                cb(false, 401, '无法验证令牌签名.')\n            }\n\n            cb(true)\n        } catch (e) {\n            console.info(e);\n            cb(false, 401, 'Token could not be parsed from the request.');\n        }\n\n    },\n});\n\nconst clients = {};\n\nwss.on('connection', (ws, req) => {\n    try {\n        const urlParams = url.parse(req.url, true);\n        const token = urlParams.query.token || req.headers.authorization.split(' ')[1];\n        const jwtSecret = env('JWT_SECRET');\n        const algorithm = env('JWT_ALGO', 'HS256');\n\n        const {sub} = jwt.verify(token, jwtSecret, {algorithm});\n        const uuid = sub;\n\n        ws.uuid = uuid;\n        if (!clients[uuid]) {\n            clients[uuid] = [];\n        }\n\n        clients[uuid].push(ws);\n    } catch (e) {\n        ws.close();\n    }\n\n    ws.on('message', message => { // 接收消息事件\n        if (ws.uuid) {\n            console.info('[%s] message：%s %s', getNowDateTimeString(), ws.uuid, message);\n        }\n    });\n\n    ws.on('close', () => { // 关闭链接事件\n        if (ws.uuid) {\n            console.info('[%s] closed：%s', getNowDateTimeString(), ws.uuid);\n\n            const wss = clients[ws.uuid];\n\n            if (wss instanceof Array) {\n                const index = wss.indexOf(ws);\n\n                if (index > -1) {\n                    wss.splice(index, 1);\n                    if (wss.length === 0) {\n                        delete clients[ws.uuid];\n                    }\n                }\n            }\n        }\n    })\n});\n\n\n// redis 订阅\nredis.psubscribe('*', function (err, count) {\n});\n\nredis.on('pmessage', (subscrbed, channel, message) => { // 接收 laravel 推送的消息\n    console.info('[%s] %s %s', getNowDateTimeString(), channel, message);\n\n    const {event} = JSON.parse(message);\n    const uuid = channel.split('.')[1];\n    const wss = clients[uuid];\n\n    switch (event) {\n        case 'Illuminate\\\\Notifications\\\\Events\\\\BroadcastNotificationCreated':\n        case 'App\\\\Events\\\\WechatScanLogin':\n            if (wss instanceof Array) {\n                wss.forEach(ws => {\n                    if (ws.readyState === 1) {\n                        ws.send(message);\n                    }\n                });\n            }\n            break;\n    }\n});\n\nfunction env(key, def = '') {\n    return config[key] || def\n}\n\nfunction getNowDateTimeString() {\n    const date = new Date();\n    return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()} ${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;\n}\n```\n\n演示地址：https://www.einsition.com/auth/login"
}
